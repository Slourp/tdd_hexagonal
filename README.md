# ğŸ’¡ Craftsmanship en DÃ©veloppement Logiciel

## Principes du Craftsmanship :

- ğŸ‘©â€ğŸ“ Apprentissage continu : Le craftsmanship implique un engagement Ã  amÃ©liorer en permanence ses compÃ©tences et ses connaissances dans le domaine du dÃ©veloppement logiciel.
- ğŸŒŸ Orientation qualitÃ© : Le craftsmanship met l'accent sur la livraison d'un logiciel de haute qualitÃ© en accordant une attention aux dÃ©tails, en garantissant la correction du code et en respectant les meilleures pratiques.
- ğŸ§¹ Code propre : Les artisans s'efforcent d'Ã©crire un code propre, lisible et maintenable qui suit les normes et les principes de codage.
- âœ”ï¸ Tests : Le craftsmanship favorise une forte focalisation sur les tests automatisÃ©s pour garantir la fiabilitÃ© et la justesse du logiciel.
- ğŸ¤ Collaboration : Les artisans accordent une grande importance Ã  la collaboration et sollicitent activement les retours de leurs pairs pour amÃ©liorer leur travail et amÃ©liorer le rÃ©sultat global.
- â™»ï¸ Refactoring : Le craftsmanship encourage la pratique du refactoring rÃ©gulier du code pour amÃ©liorer sa conception, sa maintenabilitÃ© et son efficacitÃ©.
- ğŸŒ Connaissance du domaine : Les artisans s'efforcent de comprendre le domaine dans lequel ils travaillent, ce qui leur permet de crÃ©er des solutions logicielles qui rÃ©pondent efficacement aux exigences mÃ©tier.
- ğŸ¯ SimplicitÃ© : Le craftsmanship promeut le principe de simplicitÃ©, en Ã©vitant toute complexitÃ© inutile et en recherchant des solutions simples et Ã©lÃ©gantes.
- ğŸ“¢ Communication : Les artisans accordent une grande importance Ã  la communication efficace avec les parties prenantes, les membres de l'Ã©quipe et les utilisateurs, garantissant une comprÃ©hension claire des exigences et des attentes.
- ğŸ‘” Professionnalisme : Le craftsmanship englobe le professionnalisme dans le dÃ©veloppement logiciel, y compris l'Ã©thique, la responsabilitÃ© et l'engagement Ã  apporter de la valeur aux clients ou aux utilisateurs finaux.

## Les 4 Axiomes du Craftsmanship :

1. ğŸš€ Rapid Feedback (RÃ©troaction Rapide) : Les artisans valorisent les cycles de feedback rapides pour obtenir des commentaires sur leur travail et pouvoir apporter des amÃ©liorations constantes.
2. ğŸ”¬ Assume Variability (Assumer la VariabilitÃ©) : Les artisans comprennent que la variabilitÃ© est une rÃ©alitÃ© du dÃ©veloppement logiciel et s'adaptent aux changements de maniÃ¨re proactive plutÃ´t que de rÃ©sister Ã  ces changements.
3. ğŸ§ª Embrace Failure (Accepter l'Ã‰chec) : Les artisans considÃ¨rent les erreurs et les Ã©checs comme des opportunitÃ©s d'apprentissage et d'amÃ©lioration, encourageant l'expÃ©rimentation et l'innovation.
4. ğŸŒ± Continuous Improvement (AmÃ©lioration Continue) : Les artisans cherchent constamment Ã  s'amÃ©liorer en adoptant une approche itÃ©rative et en apprenant de leurs expÃ©riences, de leurs pairs et de la communautÃ©.

Ces points capturent les principes fondamentaux du craftsmanship en dÃ©veloppement logiciel, mettant en Ã©vidence l'importance de l'apprentissage continu, de la qualitÃ©, de la collaboration, de la simplicitÃ© et des axiomes du feedback rapide, de l'assomption de la variabilitÃ©, de l'acceptation de l'Ã©chec et de l'amÃ©lioration continue.


## Les qualitÃ©s d'un logiciel :
### StabilitÃ©

- **Change Failure Rate** (Taux d'Ã©chec lors des changements) : Mesure la capacitÃ© d'un logiciel Ã  gÃ©rer les changements sans introduire de nouveaux problÃ¨mes ou de bugs. Un faible taux d'Ã©chec lors des changements indique que le logiciel est robuste et rÃ©sistant aux modifications.
- **Recovery Failure Time** (Temps de rÃ©cupÃ©ration en cas d'Ã©chec) : Mesure la capacitÃ© d'un logiciel Ã  se rÃ©tablir rapidement aprÃ¨s un incident ou un Ã©chec. Un temps de rÃ©cupÃ©ration court minimise les interruptions de service et permet de restaurer les fonctionnalitÃ©s normales du logiciel dans les plus brefs dÃ©lais.

### Throughput (FrÃ©quence de dÃ©ploiement)

- **Lead time** (Temps nÃ©cessaire pour la mise en production d'une idÃ©e) : Mesure le temps Ã©coulÃ© depuis la conception d'une idÃ©e jusqu'Ã  sa mise en production. Un lead time court permet une mise en production rapide des nouvelles fonctionnalitÃ©s et idÃ©es.
- **Deployment Frequency** (FrÃ©quence des changements publiÃ©s en production) : Mesure la frÃ©quence Ã  laquelle les changements et les nouvelles fonctionnalitÃ©s sont dÃ©ployÃ©s en production. Une frÃ©quence Ã©levÃ©e indique une capacitÃ© Ã  itÃ©rer rapidement et Ã  rÃ©pondre aux besoins changeants du logiciel.

Ces deux aspects, la stabilitÃ© et le throughput, sont essentiels pour la crÃ©ation de logiciels performants et fiables. La stabilitÃ© garantit la rÃ©silience et la fiabilitÃ© du logiciel face aux changements, tandis que le throughput favorise une mise en production rapide et itÃ©rative des nouvelles fonctionnalitÃ©s.

Ces qualitÃ©s combinÃ©es contribuent Ã  la satisfaction des utilisateurs, Ã  la rentabilitÃ© des entreprises et Ã  l'amÃ©lioration continue des applications logicielles.

## Principes F.I.R.S.T des tests unitaires

- **Fast (Rapides)** : Les tests unitaires doivent Ãªtre rapides, c'est-Ã -dire qu'ils doivent s'exÃ©cuter rapidement pour permettre une rÃ©troaction rapide sur l'Ã©tat du code. Des tests lents peuvent ralentir le processus de dÃ©veloppement et dÃ©courager leur exÃ©cution rÃ©guliÃ¨re.

- **Independent (IndÃ©pendants)** : Les tests unitaires doivent Ãªtre indÃ©pendants les uns des autres, ce qui signifie qu'ils ne doivent pas dÃ©pendre de l'ordre d'exÃ©cution ou des rÃ©sultats d'autres tests. Cela garantit que chaque test peut Ãªtre exÃ©cutÃ© individuellement et qu'un Ã©chec dans un test n'affecte pas les autres.

- **Repeatable (Reproductibles)** : Les tests unitaires doivent Ãªtre reproductibles, ce qui signifie qu'ils doivent donner les mÃªmes rÃ©sultats Ã  chaque exÃ©cution. Cela permet de dÃ©tecter rapidement les problÃ¨mes et d'assurer la fiabilitÃ© des tests.

- **Self-Validating (Auto-validants)** : Les tests unitaires doivent Ãªtre auto-validants, c'est-Ã -dire qu'ils doivent pouvoir s'exÃ©cuter sans intervention manuelle et dÃ©terminer automatiquement si le rÃ©sultat est conforme aux attentes. Cela facilite l'automatisation des tests et rÃ©duit les erreurs humaines.

- **Timely (Opportuns | Toughrough)** : Les tests unitaires doivent Ãªtre Ã©crits en mÃªme temps (ou mÃªme avant) le code qu'ils testent. Ils doivent Ãªtre maintenus Ã  jour au fur et Ã  mesure que le code Ã©volue. Cela garantit une couverture adÃ©quate et permet de dÃ©tecter rapidement les rÃ©gressions.

Ces principes, y compris la lisibilitÃ© et la concision, aident Ã  Ã©tablir des bonnes pratiques pour la crÃ©ation et la maintenance des tests unitaires. En les suivant, vous pouvez crÃ©er des tests plus efficaces, fiables et Ã©volutifs pour assurer la qualitÃ© du code.

## Pattern Object Mother (Test Data Builder)

Le pattern Object Mother est un patron de conception de crÃ©ation (creational design pattern) qui offre un moyen pratique de crÃ©er des instances d'objets complexes, gÃ©nÃ©ralement utilisÃ© dans des scÃ©narios de tests. Il est Ã©galement connu sous le nom de Test Data Builder. Ce pattern permet d'encapsuler la logique de crÃ©ation d'objets et fournit une API claire et rÃ©utilisable pour la crÃ©ation de donnÃ©es de test.

Voici un exemple illustrant le pattern Object Mother :

```javascript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  // Getters and other methods...
}

class UserMother {
  static createJohnDoe() {
    return new User('John Doe', 'john@example.com');
  }

  static createJaneSmith() {
    return new User('Jane Smith', 'jane@example.com');
  }
}

// Utilisation :
const johnDoe = UserMother.createJohnDoe();
const janeSmith = UserMother.createJaneSmith();
```

Dans cet exemple, la classe `UserMother` encapsule la logique de crÃ©ation d'instances prÃ©configurÃ©es de la classe `User`. Elle fournit des mÃ©thodes statiques telles que `createJohnDoe()` et `createJaneSmith()` qui renvoient des instances de `User` prÃ©configurÃ©es avec des valeurs d'attributs spÃ©cifiques. Cela permet une crÃ©ation de donnÃ©es de test facile et cohÃ©rente, sans duplication de la logique de crÃ©ation d'objets dans diffÃ©rents cas de test.

En utilisant le pattern Object Mother, vous pouvez centraliser la crÃ©ation d'objets de test complexes, garantir la cohÃ©rence et amÃ©liorer la lisibilitÃ© de vos tests. Il offre une maniÃ¨re propre et rÃ©utilisable de crÃ©er des donnÃ©es de test, rendant vos tests plus faciles Ã  maintenir et rÃ©duisant la duplication de code.

Veuillez noter que le pattern Object Mother n'est pas limitÃ© Ã  la crÃ©ation de donnÃ©es de test ; il peut Ã©galement Ãªtre utilisÃ© dans d'autres situations oÃ¹ vous devez crÃ©er des instances d'objets complexes avec des configurations prÃ©dÃ©finies.

J'espÃ¨re que cela clarifie le pattern Object Mother pour vous. N'hÃ©sitez pas Ã  me faire savoir si vous avez d'autres questions !

## Pattern Builder pour les tests

Le pattern Builder est un patron de conception de crÃ©ation (creational design pattern) qui permet de construire des objets complexes en Ã©tapes. Dans le contexte des tests, le pattern Builder est souvent utilisÃ© pour crÃ©er des objets de test avec des configurations spÃ©cifiques de maniÃ¨re fluide et lisible.

Voici un exemple d'implÃ©mentation du pattern Builder pour les tests en JavaScript :

```javascript
class UserBuilder {
  constructor() {
    this.name = '';
    this.email = '';
    this.age = 0;
  }

  withName(name) {
    this.name = name;
    return this;
  }

  withEmail(email) {
    this.email = email;
    return this;
  }

  withAge(age) {
    this.age = age;
    return this;
  }

  build() {
    return {
      name: this.name,
      email: this.email,
      age: this.age,
    };
  }
}

// Usage :
const user = new UserBuilder()
  .withName('John Doe')
  .withEmail('john@example.com')
  .withAge(25)
  .build();
```

Dans cet exemple, la classe `UserBuilder` dÃ©finit les Ã©tapes de construction d'un objet `User` avec des attributs spÃ©cifiques. Les mÃ©thodes `withName`, `withEmail` et `withAge` permettent de dÃ©finir les valeurs des attributs. La mÃ©thode `build` est utilisÃ©e pour crÃ©er un objet littÃ©ral avec les valeurs dÃ©finies. L'utilisation fluide du pattern Builder permet de chaÃ®ner les appels de mÃ©thode de maniÃ¨re lisible et expressive.

Le pattern Builder facilite la crÃ©ation d'objets de test avec des configurations personnalisÃ©es sans avoir Ã  spÃ©cifier tous les attributs Ã  chaque fois. Il offre une syntaxe fluide et permet de rendre les tests plus lisibles et maintenables. De plus, le pattern Builder peut Ãªtre Ã©tendu pour prendre en charge des scÃ©narios plus complexes avec des configurations optionnelles ou conditionnelles.
